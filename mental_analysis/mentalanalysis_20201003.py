# -*- coding: utf-8 -*-
"""MentalAnalysis_20201003.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FEjLJ9r4veywYKdwHP431tHX_i_j-IKq

Library
"""

import pandas as pd
from sklearn.model_selection import train_test_split
import lightgbm as lgbm
from sklearn.metrics import confusion_matrix, accuracy_score
from sklearn.preprocessing import LabelEncoder
import numpy as np
from keras.utils import np_utils
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import OneHotEncoder

"""데이터 로드"""

train=pd.read_csv('../content/train.csv', index_col=0) #인덱스 col=0도 check!
test=pd.read_csv('../content/test_x.csv', index_col=0)
submission=pd.read_csv('../content/sample_submission.csv', index_col=0)

"""데이터 전처리 (preprocessing)"""

#print(train.describe())

#print(train.info())

train_x = train.drop('voted', axis = 1)
train_y = train['voted']

#데이터 전처리 : 문자열을 숫자로 변환
ageLabel = LabelEncoder()
ageLabel.fit(train_x['age_group'])
train_x['age_group'] = ageLabel.transform(train_x['age_group'])
test['age_group'] = ageLabel.transform(test['age_group'])

genderLabel = LabelEncoder()
genderLabel.fit(train_x['gender'])
train_x['gender'] = genderLabel.transform(train_x['gender'])
test['gender'] = genderLabel.transform(test['gender'])

raceLabel = LabelEncoder()
raceLabel.fit(train_x['race'])
train_x['race'] = raceLabel.transform(train_x['race'])
test['race'] = raceLabel.transform(test['race'])
pd
religionLabel = LabelEncoder()
religionLabel.fit(train_x['religion'])
train_x['religion'] = religionLabel.transform(train_x['religion'])
test['religion'] = religionLabel.transform(test['religion'])

#One-hot-encoding
train_x['age_group'] = train_x['age_group'].astype('category')
test['age_group'] = test['age_group'].astype('category')

train_x['education'] = train_x['education'].astype('category')
test['education'] = test['education'].astype('category')
 
train_x['engnat'] = train_x['engnat'].astype('category')
test['engnat'] = test['engnat'].astype('category')

train_x['gender'] = train_x['gender'].astype('category')
test['gender'] = test['gender'].astype('category')

train_x['hand'] = train_x['hand'].astype('category')
test['hand'] = test['hand'].astype('category')

train_x['married'] = train_x['married'].astype('category')
test['married'] = test['married'].astype('category')

train_x['race'] = train_x['race'].astype('category')
test['race'] = test['race'].astype('category')

train_x['religion'] = train_x['religion'].astype('category')
test['religion'] = test['religion'].astype('category')

train_x['urban'] = train_x['urban'].astype('category')
test['urban'] = test['urban'].astype('category')

train_x = pd.get_dummies(train_x)
test = pd.get_dummies(test)

#이상 데이터 제거 : QE 값 중 20000을 넘는 겂은 20000으로 변환
limit = 20000
train_x["QaE"] = (train_x["QaE"]).apply(lambda x: min(x, limit))
train_x["QbE"] = (train_x["QbE"]).apply(lambda x: min(x, limit))
train_x["QcE"] = (train_x["QcE"]).apply(lambda x: min(x, limit))
train_x["QdE"] = (train_x["QdE"]).apply(lambda x: min(x, limit))
train_x["QeE"] = (train_x["QeE"]).apply(lambda x: min(x, limit))
train_x["QfE"] = (train_x["QfE"]).apply(lambda x: min(x, limit))
train_x["QgE"] = (train_x["QgE"]).apply(lambda x: min(x, limit))
train_x["QhE"] = (train_x["QhE"]).apply(lambda x: min(x, limit))
train_x["QiE"] = (train_x["QiE"]).apply(lambda x: min(x, limit))
train_x["QjE"] = (train_x["QjE"]).apply(lambda x: min(x, limit))
train_x["QkE"] = (train_x["QkE"]).apply(lambda x: min(x, limit))
train_x["QlE"] = (train_x["QlE"]).apply(lambda x: min(x, limit))
train_x["QmE"] = (train_x["QmE"]).apply(lambda x: min(x, limit))
train_x["QnE"] = (train_x["QnE"]).apply(lambda x: min(x, limit))
train_x["QoE"] = (train_x["QoE"]).apply(lambda x: min(x, limit))
train_x["QpE"] = (train_x["QpE"]).apply(lambda x: min(x, limit))
train_x["QqE"] = (train_x["QqE"]).apply(lambda x: min(x, limit))
train_x["QrE"] = (train_x["QrE"]).apply(lambda x: min(x, limit))
train_x["QsE"] = (train_x["QsE"]).apply(lambda x: min(x, limit))
train_x["QtE"] = (train_x["QtE"]).apply(lambda x: min(x, limit)) 

test["QaE"] = (test["QaE"]).apply(lambda x: min(x, limit))
test["QbE"] = (test["QbE"]).apply(lambda x: min(x, limit))
test["QcE"] = (test["QcE"]).apply(lambda x: min(x, limit))
test["QdE"] = (test["QdE"]).apply(lambda x: min(x, limit))
test["QeE"] = (test["QeE"]).apply(lambda x: min(x, limit))
test["QfE"] = (test["QfE"]).apply(lambda x: min(x, limit))
test["QgE"] = (test["QgE"]).apply(lambda x: min(x, limit))
test["QhE"] = (test["QhE"]).apply(lambda x: min(x, limit))
test["QiE"] = (test["QiE"]).apply(lambda x: min(x, limit))
test["QjE"] = (test["QjE"]).apply(lambda x: min(x, limit))
test["QkE"] = (test["QkE"]).apply(lambda x: min(x, limit))
test["QlE"] = (test["QlE"]).apply(lambda x: min(x, limit))
test["QmE"] = (test["QmE"]).apply(lambda x: min(x, limit))
test["QnE"] = (test["QnE"]).apply(lambda x: min(x, limit))
test["QoE"] = (test["QoE"]).apply(lambda x: min(x, limit))
test["QpE"] = (test["QpE"]).apply(lambda x: min(x, limit))
test["QqE"] = (test["QqE"]).apply(lambda x: min(x, limit))
test["QrE"] = (test["QrE"]).apply(lambda x: min(x, limit))
test["QsE"] = (test["QsE"]).apply(lambda x: min(x, limit))
test["QtE"] = (test["QtE"]).apply(lambda x: min(x, limit))

train_x.describe()

"""test데이터를 70% (test) 30% (valid)로 분리해서 validation data 평가 """

#데이터 표준화
scaler = StandardScaler()   # sclaer 선택
 
scaler.fit(train_x)            # scaling을 위한 parameter 구하기
scaler.transform(train_x)      # fit된 정보에 맞게 transform 
scaler.transform(test)      # fit된 정보에 맞게 transform

#train 데이터와 validData 분리

train_sample_x = train_x[:31872]
valid_data_x = train_x[31872:] #13660

train_sample_y = train_y[:31872]
valid_data_y = train_y[31872:] #13660

# lgbm으로 분석
model = lgbm.LGBMClassifier(n_estimators=500)
model.fit(train_sample_x, train_sample_y)

train_out = model.predict(valid_data_x)  
score = 0
for i in range(13660):
    if valid_data_y[i+31872] == train_out[i]:
        score = score+1

score/13660

"""test 데이터 전체 학습"""

# lgbm으로 분석
model = lgbm.LGBMClassifier(n_estimators=500)
model.fit(train_x, train_y)

train_out = model.predict(train_x) 

score = 0
for i in range(45532):
    if train_y[i] == train_out[i]:
        score = score+1

score/45532

pred_y = model.predict(test)
submission['voted']=pred_y
submission.to_csv('../content/sample_submission_12.csv')

